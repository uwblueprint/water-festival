Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Recording = exports.Sound = exports.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = exports.INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = exports.INTERRUPTION_MODE_IOS_DUCK_OTHERS = exports.INTERRUPTION_MODE_IOS_DO_NOT_MIX = exports.INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY = exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class,
    _temp,
    _this4 = this;

exports.setIsEnabledAsync = setIsEnabledAsync;
exports.setAudioModeAsync = setAudioModeAsync;

var _reactNative = require('react-native');

var _AV = require('./AV');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regeneratorRuntime = require('regenerator-runtime');

var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;
var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;

var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;
var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS = 6;

var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';
var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';

var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;
var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;
var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;
var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;
var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;

var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;
var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;
var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;
var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;

var RECORDING_OPTIONS_PRESET_HIGH_QUALITY = exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {
  android: {
    extension: '.m4a',
    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,
    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,
    sampleRate: 44100,
    numberOfChannels: 2,
    bitRate: 128000
  },
  ios: {
    extension: '.caf',
    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,
    sampleRate: 44100,
    numberOfChannels: 2,
    bitRate: 128000,
    linearPCMBitDepth: 16,
    linearPCMIsBigEndian: false,
    linearPCMIsFloat: false
  }
};

var RECORDING_OPTIONS_PRESET_LOW_QUALITY = exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY = {
  android: {
    extension: '.3gp',
    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,
    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,
    sampleRate: 44100,
    numberOfChannels: 2,
    bitRate: 128000
  },
  ios: {
    extension: '.caf',
    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,
    sampleRate: 44100,
    numberOfChannels: 2,
    bitRate: 128000,
    linearPCMBitDepth: 16,
    linearPCMIsBigEndian: false,
    linearPCMIsFloat: false
  }
};

var INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = exports.INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;
var INTERRUPTION_MODE_IOS_DO_NOT_MIX = exports.INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;
var INTERRUPTION_MODE_IOS_DUCK_OTHERS = exports.INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;

var INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = exports.INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;
var INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = exports.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2;

var _enabled = true;
var _recorderExists = false;
var _DISABLED_ERROR = new Error('Cannot complete operation because audio is not enabled.');

var _isValueValid = function _isValueValid(value, validValues) {
  return validValues.filter(function (validValue) {
    return validValue === value;
  }).length > 0;
};

var _findMissingKeys = function _findMissingKeys(object, requiredKeys) {
  return requiredKeys.filter(function (requiredKey) {
    return !(requiredKey in object);
  });
};

function setIsEnabledAsync(value) {
  return regeneratorRuntime.async(function setIsEnabledAsync$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _enabled = value;
          _context.next = 3;
          return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.setAudioIsEnabled(value));

        case 3:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

function setAudioModeAsync(mode) {
  var missingKeys;
  return regeneratorRuntime.async(function setAudioModeAsync$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          missingKeys = _findMissingKeys(mode, ['allowsRecordingIOS', 'interruptionModeIOS', 'playsInSilentModeIOS', 'interruptionModeAndroid', 'shouldDuckAndroid']);

          if (!(missingKeys.length > 0)) {
            _context2.next = 3;
            break;
          }

          throw new Error('Audio mode attempted to be set without the required keys: ' + JSON.stringify(missingKeys));

        case 3:
          if (_isValueValid(mode.interruptionModeIOS, [INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS, INTERRUPTION_MODE_IOS_DO_NOT_MIX, INTERRUPTION_MODE_IOS_DUCK_OTHERS])) {
            _context2.next = 5;
            break;
          }

          throw new Error('"interruptionModeIOS" was set to an invalid value.');

        case 5:
          if (_isValueValid(mode.interruptionModeAndroid, [INTERRUPTION_MODE_ANDROID_DO_NOT_MIX, INTERRUPTION_MODE_ANDROID_DUCK_OTHERS])) {
            _context2.next = 7;
            break;
          }

          throw new Error('"interruptionModeAndroid" was set to an invalid value.');

        case 7:
          if (!(typeof mode.allowsRecordingIOS !== 'boolean' || typeof mode.playsInSilentModeIOS !== 'boolean' || typeof mode.shouldDuckAndroid !== 'boolean')) {
            _context2.next = 9;
            break;
          }

          throw new Error('"allowsRecordingIOS", "playsInSilentModeIOS", and "shouldDuckAndroid" must be booleans.');

        case 9:
          _context2.next = 11;
          return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.setAudioMode(mode));

        case 11:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
}

var Sound = exports.Sound = (_temp = _class = function () {
  function Sound() {
    var _this = this;

    _classCallCheck(this, Sound);

    this._internalStatusUpdateCallback = function (status) {
      _this._callOnPlaybackStatusUpdateForNewStatus(status);
      _this._setInternalStatusUpdateCallback();
    };

    this._errorCallback = function (error) {
      _this._loaded = false;
      _this._key = -1;
      _this._callOnPlaybackStatusUpdateForNewStatus((0, _AV._getUnloadedStatus)(error));
    };

    this.getStatusAsync = function _callee() {
      var status;
      return regeneratorRuntime.async(function _callee$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!_this._loaded) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return', _this._performOperationAndHandleStatusAsync(function () {
                return _reactNative.NativeModules.ExponentAV.getStatusForSound(_this._key);
              }));

            case 2:
              status = (0, _AV._getUnloadedStatus)();

              _this._callOnPlaybackStatusUpdateForNewStatus(status);
              return _context3.abrupt('return', status);

            case 5:
            case 'end':
              return _context3.stop();
          }
        }
      }, null, _this);
    };

    this.setCallback = function (callback) {
      console.warn('\'Sound.setCallback()\' is deprecated and will be removed in SDK21. Use \'Sound.setOnPlaybackStatusUpdate()\' instead.');
      _this.setOnPlaybackStatusUpdate(callback);
    };

    this._loaded = false;
    this._loading = false;
    this._key = -1;
    this._onPlaybackStatusUpdate = null;
  }

  _createClass(Sound, [{
    key: '_callOnPlaybackStatusUpdateForNewStatus',
    value: function _callOnPlaybackStatusUpdateForNewStatus(status) {
      if (this._onPlaybackStatusUpdate != null) {
        this._onPlaybackStatusUpdate(status);
      }
    }
  }, {
    key: '_performOperationAndHandleStatusAsync',
    value: function _performOperationAndHandleStatusAsync(operation) {
      var _status;

      return regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (_enabled) {
                _context4.next = 2;
                break;
              }

              throw _DISABLED_ERROR;

            case 2:
              if (!this._loaded) {
                _context4.next = 10;
                break;
              }

              _context4.next = 5;
              return regeneratorRuntime.awrap(operation());

            case 5:
              _status = _context4.sent;

              this._callOnPlaybackStatusUpdateForNewStatus(_status);
              return _context4.abrupt('return', _status);

            case 10:
              throw new Error('Cannot complete operation because sound is not loaded.');

            case 11:
            case 'end':
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: '_setInternalStatusUpdateCallback',
    value: function _setInternalStatusUpdateCallback() {
      if (this._loaded) {
        _reactNative.NativeModules.ExponentAV.setStatusUpdateCallbackForSound(this._key, this._internalStatusUpdateCallback);
      }
    }
  }, {
    key: 'setOnPlaybackStatusUpdate',
    value: function setOnPlaybackStatusUpdate(onPlaybackStatusUpdate) {
      this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;
      this.getStatusAsync();
    }
  }, {
    key: 'loadAsync',
    value: function loadAsync(source) {
      var initialStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var downloadFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var _ref, uri, fullInitialStatus;

      return regeneratorRuntime.async(function loadAsync$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (_enabled) {
                _context5.next = 2;
                break;
              }

              throw _DISABLED_ERROR;

            case 2:
              if (!this.loading) {
                _context5.next = 4;
                break;
              }

              throw new Error('The Sound is already loading.');

            case 4:
              if (this._loaded) {
                _context5.next = 14;
                break;
              }

              this._loading = true;

              _context5.next = 8;
              return regeneratorRuntime.awrap((0, _AV._getURIAndFullInitialStatusForLoadAsync)(source, initialStatus, downloadFirst));

            case 8:
              _ref = _context5.sent;
              uri = _ref.uri;
              fullInitialStatus = _ref.fullInitialStatus;
              return _context5.abrupt('return', new Promise(function (resolve, reject) {
                var _this2 = this;

                var loadSuccess = function loadSuccess(key, status) {
                  _this2._key = key;
                  _this2._loaded = true;
                  _this2._loading = false;
                  _reactNative.NativeModules.ExponentAV.setErrorCallbackForSound(_this2._key, _this2._errorCallback);
                  _this2._setInternalStatusUpdateCallback();
                  _this2._callOnPlaybackStatusUpdateForNewStatus(status);
                  resolve(status);
                };
                var loadError = function loadError(error) {
                  _this2._loading = false;
                  reject(new Error(error));
                };
                _reactNative.NativeModules.ExponentAV.loadForSound(uri, fullInitialStatus, loadSuccess, loadError);
              }.bind(this)));

            case 14:
              throw new Error('The Sound is already loaded.');

            case 15:
            case 'end':
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'unloadAsync',
    value: function unloadAsync() {
      var key, _status2;

      return regeneratorRuntime.async(function unloadAsync$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!this._loaded) {
                _context6.next = 11;
                break;
              }

              this._loaded = false;
              key = this._key;

              this._key = -1;
              _context6.next = 6;
              return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.unloadForSound(key));

            case 6:
              _status2 = _context6.sent;

              this._callOnPlaybackStatusUpdateForNewStatus(_status2);
              return _context6.abrupt('return', _status2);

            case 11:
              return _context6.abrupt('return', this.getStatusAsync());

            case 12:
            case 'end':
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'setStatusAsync',
    value: function setStatusAsync(status) {
      var _this3 = this;

      return regeneratorRuntime.async(function setStatusAsync$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              (0, _AV._throwErrorIfValuesOutOfBoundsInStatus)(status);
              return _context7.abrupt('return', this._performOperationAndHandleStatusAsync(function () {
                return _reactNative.NativeModules.ExponentAV.setStatusForSound(_this3._key, status);
              }));

            case 2:
            case 'end':
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }]);

  return Sound;
}(), _class.create = function _callee2(source) {
  var initialStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var onPlaybackStatusUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var downloadFirst = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var sound, status;
  return regeneratorRuntime.async(function _callee2$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          sound = new Sound();

          sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);
          _context8.next = 4;
          return regeneratorRuntime.awrap(sound.loadAsync(source, initialStatus, downloadFirst));

        case 4:
          status = _context8.sent;
          return _context8.abrupt('return', { sound: sound, status: status });

        case 6:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, _this4);
}, _temp);


_extends(Sound.prototype, _AV._COMMON_AV_PLAYBACK_METHODS);

var Recording = exports.Recording = function () {
  function Recording() {
    var _this5 = this;

    _classCallCheck(this, Recording);

    this._cleanupForUnloadedRecorder = function _callee3(finalStatus) {
      return regeneratorRuntime.async(function _callee3$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _this5._canRecord = false;
              _this5._isDoneRecording = true;

              _this5._finalDurationMillis = finalStatus.durationMillis;
              _recorderExists = false;
              if (_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {
                _reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);
              }
              _this5._disablePolling();
              _context9.next = 8;
              return regeneratorRuntime.awrap(_this5.getStatusAsync());

            case 8:
              return _context9.abrupt('return', _context9.sent);

            case 9:
            case 'end':
              return _context9.stop();
          }
        }
      }, null, _this5);
    };

    this._pollingLoop = function _callee4() {
      return regeneratorRuntime.async(function _callee4$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!(_enabled && _this5._canRecord && _this5._onRecordingStatusUpdate != null)) {
                _context10.next = 10;
                break;
              }

              _this5._progressUpdateTimeoutVariable = setTimeout(_this5._pollingLoop, _this5._progressUpdateIntervalMillis);
              _context10.prev = 2;
              _context10.next = 5;
              return regeneratorRuntime.awrap(_this5.getStatusAsync());

            case 5:
              _context10.next = 10;
              break;

            case 7:
              _context10.prev = 7;
              _context10.t0 = _context10['catch'](2);

              _this5._disablePolling();

            case 10:
            case 'end':
              return _context10.stop();
          }
        }
      }, null, _this5, [[2, 7]]);
    };

    this.getStatusAsync = function _callee5() {
      var status;
      return regeneratorRuntime.async(function _callee5$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (!_this5._canRecord) {
                _context11.next = 2;
                break;
              }

              return _context11.abrupt('return', _this5._performOperationAndHandleStatusAsync(function () {
                return _reactNative.NativeModules.ExponentAV.getAudioRecordingStatus();
              }));

            case 2:
              status = _this5._isDoneRecording ? {
                canRecord: false,
                isDoneRecording: true,
                durationMillis: _this5._finalDurationMillis
              } : {
                canRecord: false,
                isDoneRecording: false
              };

              _this5._callOnRecordingStatusUpdateForNewStatus(status);
              return _context11.abrupt('return', status);

            case 5:
            case 'end':
              return _context11.stop();
          }
        }
      }, null, _this5);
    };

    this._canRecord = false;
    this._isDoneRecording = false;
    this._finalDurationMillis = 0;
    this._uri = null;
    this._progressUpdateTimeoutVariable = null;
    this._progressUpdateIntervalMillis = _AV._DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;
    this._options = null;
  }

  _createClass(Recording, [{
    key: '_disablePolling',
    value: function _disablePolling() {
      if (this._progressUpdateTimeoutVariable != null) {
        clearTimeout(this._progressUpdateTimeoutVariable);
        this._progressUpdateTimeoutVariable = null;
      }
    }
  }, {
    key: '_enablePollingIfNecessaryAndPossible',
    value: function _enablePollingIfNecessaryAndPossible() {
      if (_enabled && this._canRecord && this._onRecordingStatusUpdate != null) {
        this._disablePolling();
        this._pollingLoop();
      }
    }
  }, {
    key: '_callOnRecordingStatusUpdateForNewStatus',
    value: function _callOnRecordingStatusUpdateForNewStatus(status) {
      if (this._onRecordingStatusUpdate != null) {
        this._onRecordingStatusUpdate(status);
      }
    }
  }, {
    key: '_performOperationAndHandleStatusAsync',
    value: function _performOperationAndHandleStatusAsync(operation) {
      var _status3;

      return regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (_enabled) {
                _context12.next = 2;
                break;
              }

              throw _DISABLED_ERROR;

            case 2:
              if (!this._canRecord) {
                _context12.next = 10;
                break;
              }

              _context12.next = 5;
              return regeneratorRuntime.awrap(operation());

            case 5:
              _status3 = _context12.sent;

              this._callOnRecordingStatusUpdateForNewStatus(_status3);
              return _context12.abrupt('return', _status3);

            case 10:
              throw new Error('Cannot complete operation because this recorder is not ready to record.');

            case 11:
            case 'end':
              return _context12.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'setOnRecordingStatusUpdate',
    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {
      this._onRecordingStatusUpdate = onRecordingStatusUpdate;
      if (onRecordingStatusUpdate == null) {
        this._disablePolling();
      } else {
        this._enablePollingIfNecessaryAndPossible();
      }
      this.getStatusAsync();
    }
  }, {
    key: 'setCallback',
    value: function setCallback(callback) {
      console.warn('\'Recording.setCallback()\' is deprecated and will be removed in SDK21. Use \'Recording.setOnRecordingStatusUpdate()\' instead.');
      this.setOnRecordingStatusUpdate(callback);
    }
  }, {
    key: 'setProgressUpdateInterval',
    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {
      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;
      this.getStatusAsync();
    }
  }, {
    key: 'prepareToRecordAsync',
    value: function prepareToRecordAsync() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;

      var extensionRegex, _ref2, uri, _status4;

      return regeneratorRuntime.async(function prepareToRecordAsync$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (_enabled) {
                _context13.next = 2;
                break;
              }

              throw _DISABLED_ERROR;

            case 2:
              if (!_recorderExists) {
                _context13.next = 4;
                break;
              }

              throw new Error('Only one Recording object can be prepared at a given time.');

            case 4:
              if (!this._isDoneRecording) {
                _context13.next = 6;
                break;
              }

              throw new Error('This Recording object is done recording; you must make a new one.');

            case 6:
              if (!(!options || !options.android || !options.ios)) {
                _context13.next = 8;
                break;
              }

              throw new Error('You must provide recording options for android and ios in order to prepare to record.');

            case 8:
              extensionRegex = /^\.\w+$/;

              if (!(!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension))) {
                _context13.next = 11;
                break;
              }

              throw new Error('Your file extensions must match ' + extensionRegex.toString() + '.');

            case 11:
              if (this._canRecord) {
                _context13.next = 27;
                break;
              }

              if (_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {
                _reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(this._cleanupForUnloadedRecorder);
              }

              _context13.next = 15;
              return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.prepareAudioRecorder(options));

            case 15:
              _ref2 = _context13.sent;
              uri = _ref2.uri;
              _status4 = _ref2.status;

              _recorderExists = true;
              this._uri = uri;
              this._options = options;
              this._canRecord = true;
              this._callOnRecordingStatusUpdateForNewStatus(_status4);
              this._enablePollingIfNecessaryAndPossible();
              return _context13.abrupt('return', _status4);

            case 27:
              throw new Error('This Recording object is already prepared to record.');

            case 28:
            case 'end':
              return _context13.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'startAsync',
    value: function startAsync() {
      return regeneratorRuntime.async(function startAsync$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt('return', this._performOperationAndHandleStatusAsync(function () {
                return _reactNative.NativeModules.ExponentAV.startAudioRecording();
              }));

            case 1:
            case 'end':
              return _context14.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'pauseAsync',
    value: function pauseAsync() {
      return regeneratorRuntime.async(function pauseAsync$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              return _context15.abrupt('return', this._performOperationAndHandleStatusAsync(function () {
                return _reactNative.NativeModules.ExponentAV.pauseAudioRecording();
              }));

            case 1:
            case 'end':
              return _context15.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'stopAndUnloadAsync',
    value: function stopAndUnloadAsync() {
      var finalStatus;
      return regeneratorRuntime.async(function stopAndUnloadAsync$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (this._canRecord) {
                _context16.next = 6;
                break;
              }

              if (!this._isDoneRecording) {
                _context16.next = 5;
                break;
              }

              throw new Error('Cannot unload a Recording that has already been unloaded.');

            case 5:
              throw new Error('Cannot unload a Recording that has not been prepared.');

            case 6:
              _context16.next = 8;
              return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.stopAudioRecording());

            case 8:
              finalStatus = _context16.sent;
              _context16.next = 11;
              return regeneratorRuntime.awrap(_reactNative.NativeModules.ExponentAV.unloadAudioRecorder());

            case 11:
              return _context16.abrupt('return', this._cleanupForUnloadedRecorder(finalStatus));

            case 12:
            case 'end':
              return _context16.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'getURI',
    value: function getURI() {
      return this._uri;
    }
  }, {
    key: 'createNewLoadedSound',
    value: function createNewLoadedSound() {
      var initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return regeneratorRuntime.async(function createNewLoadedSound$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (!(this._uri == null || !this._isDoneRecording)) {
                _context17.next = 2;
                break;
              }

              throw new Error('Cannot create sound when the Recording has not finished!');

            case 2:
              return _context17.abrupt('return', Sound.create({ uri: this._uri }, initialStatus, onPlaybackStatusUpdate, false));

            case 3:
            case 'end':
              return _context17.stop();
          }
        }
      }, null, this);
    }
  }]);

  return Recording;
}();